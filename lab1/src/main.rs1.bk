use std::sync::{Arc};
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;
use std::time::Duration;
use std::io::Write;

fn thread_func(number: char, stop_flag: Arc<AtomicBool>) -> i32 {
    print!("\nПоток {} запущен\n", number);
    let mut stop_flag = false;
    while !stop_flag.load(Ordering::Relaxed){
        print!("{}", number);
        std::io::stdout().flush().unwrap();      // Вывод цифр на экран
        thread::sleep(Duration::from_secs(1));
    }
    // Код завершения потока
    if number == '1' {
        1
    } else {
        2
    }
}

fn main() {
    let mut stop_flag_1 = false;
    let mut stop_flag_2 = false;

  //let flag_1 = Arc::clone(&stop_flag_1);
  //let flag_2 = Arc::clone(&stop_flag_2);

    let handle1 = thread::spawn(move || thread_func('1', stop_flag_1));
    let handle2 = thread::spawn(move || thread_func('2', stop_flag_2));

    println!("Нажмите Enter, чтобы остановить выполнение...");
    let _ = std::io::stdin().read_line(&mut String::new()).unwrap();

    stop_flag_1 = true;
    stop_flag_2 = true;

    let exit_code_1 = handle1.join().unwrap();
    let exit_code_2 = handle2.join().unwrap();

    println!("\nПоток {} был завершен", exit_code_1);
    println!("Поток {} был завершен", exit_code_2);
}

